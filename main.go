package main

import (
	"fmt"
	"math/rand"
	"net/http"
	"strconv"
	"time"

	"github.com/dgrijalva/jwt-go"
	"github.com/gin-gonic/gin"
	"github.com/mynameismaxz/basic_golang/fizzbuzz"
)

// Generated by https://quicktype.io

type Response struct {
	Number string `json:"number" xml:"number"`
	Result string `json:"result" xml:"result"`
}

type FuzzResponse struct {
	Number  string `json:"number"`
	Message string `json:"message"`
}

type Users []User

type User struct {
	ID       int64   `json:"id"`
	Name     string  `json:"name"`
	Username string  `json:"username"`
	Email    string  `json:"email"`
	Address  Address `json:"address"`
	Phone    string  `json:"phone"`
	Website  string  `json:"website"`
	Company  Company `json:"company"`
}

type Address struct {
	Street  string `json:"street"`
	Suite   string `json:"suite"`
	City    string `json:"city"`
	Zipcode string `json:"zipcode"`
	Geo     Geo    `json:"geo"`
}

type Geo struct {
	Lat string `json:"lat"`
	Lng string `json:"lng"`
}

type Company struct {
	Name        string `json:"name"`
	CatchPhrase string `json:"catchPhrase"`
	Bs          string `json:"bs"`
}

func main() {
	r := gin.Default()

	r.POST("/users", usersHandler)
	r.GET("/token", tokenHandler)
	r.GET("/fizzbuzz/:number", func(c *gin.Context) {
		tokenKey := c.GetHeader("Authorization")[7:]

		token, err := jwt.Parse(tokenKey, keyFunc)
		if err != nil {
			c.JSON(http.StatusUnauthorized, map[string]string{
				"message": err.Error(),
			})
			return
		}

		if _, ok := token.Claims.(jwt.MapClaims); !ok || !token.Valid {
			// not pass
			c.JSON(http.StatusUnauthorized, gin.H{
				"message": "Unauthorized",
			})
			return
		}

		output_number := c.Param("number")
		n, err := strconv.Atoi(output_number)
		if err != nil {
			c.JSON(http.StatusBadRequest, gin.H{
				"message": err.Error(),
			})
			return
		}

		c.JSON(http.StatusOK, Response{
			Number: output_number,
			Result: fizzbuzz.New(n).String(),
		})
	})
	r.GET("/fizzbuzzr", fizzbuzzRandomHandler)

	r.Run() // listen and serve on 0.0.0.0:8080 (for windows "localhost:8080")
}

func fizzbuzzRandomHandler(c *gin.Context) {
	s2 := rand.NewSource(time.Now().UnixNano())
	r2 := rand.New(s2)
	c.JSON(http.StatusOK, fizzbuzzByRandom(r2))
}

type randomer interface {
	Intn(int) int
}

func fizzbuzzByRandom(r randomer) FuzzResponse {
	n := r.Intn(100)
	return FuzzResponse{
		Number:  strconv.Itoa(n),
		Message: fizzbuzz.New(n).String(),
	}
}

func keyFunc(token *jwt.Token) (interface{}, error) {
	// Don't forget to validate the alg is what you expect:
	if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
		return nil, fmt.Errorf("Unexpected signing method: %v", token.Header["alg"])
	}

	// hmacSampleSecret is a []byte containing your secret, e.g. []byte("my_secret_key")
	return []byte("BasicGolang"), nil
}

func tokenHandler(c *gin.Context) {
	mySigningKey := []byte("BasicGolang")

	// Create the Claims
	claims := jwt.StandardClaims{
		ExpiresAt: time.Now().Add(time.Minute * 5).Unix(),
		Issuer:    "Mac",
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	ss, err := token.SignedString(mySigningKey)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"message": err.Error(),
		})
	}

	c.JSON(http.StatusOK, gin.H{
		"token": ss,
	})
	// fmt.Printf("%v %v", ss, err)
}

func usersHandler(c *gin.Context) {
	var users Users
	err := c.Bind(&users)
	if err != nil {
		c.JSON(http.StatusBadGateway, gin.H{
			"message": err.Error(),
		})
		return
	}

	c.XML(http.StatusOK, users)
}
